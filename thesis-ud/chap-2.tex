\chapter{Methodology}
Our method can be seen as an approach built upon the idea of leaf-root path or sub-path (section~\ref{leafrootmethod}), in an operation tree~\cite{goodsurvey}. 
But we have developed this idea further in many ways. 
Our index is composed from leaf-root paths from mathematical formulae operation tree. 
The search method is traversing a ``reversed" sub-path tree, coming along with a pruning method and a proposed sub-structure test algorithm, which are utilizing some observed properties from our indexed tree. 
Apart from these, we also offer several rules of constrains to measure symbolic similarity.
This chapter gives a summary on the method intuition and the core ideas behind these.

The methods in a nutshell is, for a document expression, construct operation tree and break it down into sub-paths, index those paths by inserting them into a tree-structured index by their reversed order. For a search query, traversal index tree as the same way of going through the reversed sub-paths of that query (search path), get the search results along the merged ways from different search paths. Finally apply symbol similarity measurement algorithm or the sub-structure test algorithm to rank results.

\section{Intuitions}
First it is beneficial to document our intuitions on using operation tree as our intermediate representation and our idea to index it in a way of “reversed” sub-path tree, and also explain in abstract why this way helps reduce index space and boost search speed.
We will give an illustrative example to describe these processes further in section~\ref{secIllu}.

\subsection{Commutative immunity}
Operators with semantic implication of commutative property (e.g. addition and multiplication) are exhaustively used in mathematical language. The ability to identify the identical equations for any permutation is very essential for a mathematical similarity search engine. 
Given this as a start point, the leaf-root paths have the advantage to cope this so that we do not need to generate different order of patterns to match formulae with commutative operator. 
To illustrate this, we know that a leaf-root path from an operation tree (see figure~\ref{oprtreeExample}) is generated through traversing in a bottom-up (or top-down) fashion from a tree, thus path string is independent with the relative position of operands from same father node.
In another word, an operation tree uniquely determines the leaf-node paths decomposed from the tree, no matter how operands are ordered. 

\subsection{Sub-structure query ability}
On the other hand, the structure of operation tree also makes it easy to represent sub-expression relation with a formula, because a sub-expression in a formula is usually (depending on the way we construct an operation tree) also a subtree in an operation tree. 
And by going up from leaves of operation tree, we are essentially traversing to an expression from its subexpression for every level. 
By making all the leaf-root paths as an index, we can search an expression by going through and beyond the leaf-root paths from its subexpression. 
This makes operation tree better in terms of searching an expression given a sub-expression in query. 
And it avoids information augmentation on index as some other structure-based methods need to do (e.g. index all sub-terms of an expression in MWS~\cite{Kohlhase06}). Therefore it helps save storage space. 

\subsection{Index and search properties}
Additionally, some properties from the ``inverted" of sub-paths (we will illustrate this in section~\ref{secIllu}) from an operation tree suggest some reduce of space and pruning possibilities in search process. 
First the sub-paths themselves can be indexed into a tree so that we can search a sub-path by traversing a sub-path tree, instead of hashing it to find a corresponding value as the symbol-pair search engine (i.e. \textit{Tangent}~\cite{symbolpairs15}) does. 
This allows us to save a lot space as the reverted sub-paths of a large collection will have a great percentage of level sharing a common string with each other. 
Also the way to search in a tree structure with a limited branch factor does not lose much efficiency compared to the HASH methods used in \textit{Tangent}, while also offer great storage efficiency.
Second, by searching from all the ``reverted" sub-paths of a query expression in our proposed index, and apply an intersection on the results from different sub-paths, we will find all the expressions have that query as subexpression (number four observed property from section~\ref{observationlabel}). And during this search process, upon going further from the query expression root in the ``reverted" sub-path, we can merge the next search directories by pruning all the entries that are not shared in common among all the ``reverted" search path directories. 
Further more, multiple index search in different path level are independent with each other, put in another way, if a given indexed formula has been found in one search path level, then its other relevant sub-paths (in terms of the current query) will most likely be found at the same search level too, thus some implementation strategies can be applied to speed search further (i.e. distributed search to quick search massive), which we would address in the next chapter.

\begin{figure}
\begin{minipage}[b]{2.65in}
\begin{center}
\includegraphics[height=1.8in]{leafroottree}
\\$a(b+c)$ in operation tree
\end{center}
\end{minipage}
\hspace*{.38in}
\begin{minipage}[b]{2.65in}
\begin{center}
\raisebox{.0in}{\includegraphics[height=1.8in]{leafrootpath}}
Generated leaf-root paths
\end{center}
\end{minipage}
\caption{Leaf-root path example}\label{oprtreeExample}
\end{figure}

\section{Structure Similarity}
The basic ideas used in our approach, to test whether a mathematical expression is an sub-structure of another, to prune and to constrain search process are the foundation work in our research. It is desired to give a description in a formal language so that we can deliver these ideas in the most precise way. Some important observations as well as brief justifications are provided after definitions.

\subsection{Definitions}
For the second issue addressed in section~\ref{measure_sim}, specifically, to assess the structural similarity. 
Previous formal definitions~\cite{improving09} have been given on this, providing a quantified \mbox{$n$-similarity} relation to address the similarity degree, which is determined by the max-weight common subtree between two formulae. 
The subtree, by their definition, includes all descendants from a node. 
Nevertheless, we are going to use the subtree definition in graph theory here to describe the sub-structure relation. 
To be explicit, given a rooted tree $T$, the connected graph whose edges are also in $T$ is defined as the subtree of $T$.  

Also we need clarify some conventional notations here. 
Through this paper, a path $p \in \mathbf{P}$ is a sequence of numbers given by $p = p_0 p_1 \ldots p_n$ where $n\ge0$, $p_i \in \mathbf{R},\; 0 \le i \le n$ and $\mathbf{P}$ is the set of all paths. 
Any function $f(\cdot) = y \in \mathbf{R}$ applied on $p$ is mapped to a path too: $f(p)=f(p_0)f(p_1) \ldots f(p_n)$. 
Furthermore, for two paths $\,^1p = p_0p_1 \ldots p_n$ and $\,^2p = p_np_{n+1} \ldots p_m$ where $m \ge n$, a concatenation $\,^1p \cdot \,^2p$ is defined as $p_0p_1 \ldots p_n p_{n+1} \ldots p_m$ (said as concatenation of $\,^2p$ on $\,^1p$), 
and the concatenation of a path $p$ on a set $S = \{ s_1, s_2 \ldots s_n \}$ is defined as $S \cdot p = \{ s_1\cdot p,\  s_2\cdot p \ \ldots \ s_n\cdot p \}$. 
Usually a path with only one element is explicitly stated and wrapped by a bracket, e.g. $p=(p_0)$. 
Lastly, \textit{the longest common postfix} path $p^*$ between two path $p_1$ and $p_2$ is mapped by the function $\mathrm{lcp}$: $p^* = \mathrm{lcp}(p_1, p_2) = \mathrm{lcp}(p_2, p_1)$.

Based upon this,  we introduce a \textit{formula subtree} relation to address the sub-structure relation between two mathematical expressions. 
The formula tree is associated with a label (labels are not required to be distinct here) in each node to represent a mathematical operator, variable, constance etc., also a symbol value in each leaf node to represent a symbolic instance of that constance or variable (e.g. ``123", $\beta$, \textit{x, y} etc.). 
Below are our formal definitions.

\subsubsection{Formula tree}
A \textit{formula tree} is a labeled rooted non-empty tree $T = T(V,E,r)$ with root $r$, where each vertices $v \in V(T)$ is associated with a label $\ell(v) \in \mathbf{R}$ mapped by label function $\ell$, and each leaf $l \in V(T)$ is also associated with a symbol $s(v) \in \mathbf{R}$ mapped by symbol function $s$.

\subsubsection{Formula subtree}
\label{frmlsubtreeDef}
Given formula tree $S$ and $T$, we say $S$ is a \textit{formula subtree} of $T$ if there exists an injective mapping $\phi: V(S) \rightarrow V(T)$ satisfying:

\begin{enumerate}
\item 
$\forall\; (v_1,v_2) \in E(S)$, we have $(\phi(v_1),\phi(v_2)) \in E(T)$;
\item
$\forall\; v \in V(S)$, we have $\ell(v) = \ell(\phi(v))$;
\item
If $v \in V(S)$ is a leaf vertices in $S$, then $\phi(v)$ is also a leaf in $T$.
\end{enumerate}
Such a mapping $\phi$ is called a formula subtree isomorphic embedding (or formula embedding) for $S \rightarrow T$. 
If satisfied, we denote $S \preceq_l T$ on $\Phi$, where $\Phi$ ($\Phi \neq \emptyset$) is the set of all the possible formula embeddings for $S \rightarrow T$.

\subsubsection{Index}
An \textit{index} $\Pi$ is a set of trees such that $\forall\; T \in \Pi$, we have $T \in \mathcal{I}_{\Pi}(a)$ for any $a = \ell(p), \; p \in g(T)$, we say $T$ is indexed in $\Pi$ with respect to $a$.
Where $\mathcal{I}_{\Pi}$ is called an index look-up function. 

\subsubsection{leaf-root path set}
Lastly, a \textit{leaf-root path set} generated by tree $T$ is a set of all the leaf-root paths from tree $T$, mapped by a function $g(T)$. Therefore we have $p \in g(T)$ for any leaf-root path $p$ of tree $T$.


\subsection{Observations}
\label{observationlabel}
\subsubsection*{Observation \#1} 
For two formula trees which satisfy $T_q \preceq_l T_d$ on $\Phi$, then $\forall\; \phi \in \Phi,\, p \in g(T_q)$, also any vertices $v$ along path $p$, the following properties are obtained:
\begin{eqnarray}
\deg(v) \le \deg(\phi(v)) \label{prop1} \\
\left| p \right| = \left| \phi(p) \right| \label{prop2} \\
\ell(p) = \ell(\phi(p)) \label{prop3} \\
\left| g(T_q) \right| \le \left| g(T_d) \right| \label{prop4}
\end{eqnarray}
\textit{Justification.} 
Because $\forall\; w \in V(T_q) \  s.t. \  (v, w) \in E(T_q)$, there exists $(\phi(v), \phi(w)) \in E(T_d)$. 
And for any (if exists) two different edges $(v, w_1), (v, w_2) \in E(T_q),\, w_1 \not= w_2 \in V(T_q) $, we know $(\phi(v), \phi(w_1)) \not= (\phi(v), \phi(w_2))$ by definition~\ref{frmlsubtreeDef}. 
Therefore any different edge from $v$ is associated with a distinct edge from $\phi(v)$, thus we can get \ref{prop1}. 
Given the fact that every non-empty path $p$ can be decomposed into a series of edges $(p_0, p_1), (p_1, p_2) \ldots (p_{n-1}, p_n), \; n > 0$,
properties \ref{prop2} and \ref{prop3} are trivial.
Because there is exact one path between every two nodes in a tree, the leaf-root path is uniquely determined by a leaf node in a tree. Hence the rationale of \ref{prop4} can be obtained in a similar manner with that of \ref{prop1}, expect neighbor edges are replaced by leaf-node paths.


\subsubsection*{Observation \#2} 
Given two formula trees $T_q$ and $T_d$, if $\left| g(T_q) \right| = 1$ and $\ell(g(T_{q})) \subseteq \ell(g(T_d))$, then $T_q \preceq_l T_d$.

\noindent \textit{Justification.} 
Obviously there is only single one leaf-root path in $T_q$ because $\left| g(T_q) \right| = 1$. 
Denote the path as $p = p_0 \ldots p_n,\; n \ge 0$ where $p_n$ is the leaf, and let $a = \ell(p)$.
Since $a \subseteq \ell(g(T_d))$, we know that there must exist a path $p'=p'_0 \ldots p'_n \in g(T_d)$ such that $a = \ell(p')$.
Without loss of generality, suppose $p'_n$ is the leaf of $T_d$. 
Now the injective function $\phi: p_i \rightarrow p'_i,\  0 \le i \le n$ satisfies all the requirements for $T_q$ as a formula subtree of $T_d$.

\subsubsection*{Observation \#3} 
For two formula trees $T_q$ and $T_d$, if $T_q = T(V,E,r) \preceq_l T_d$ on $\Phi$,  
$\forall a,b \in g(T_q)$ and a mapping $\phi \in \Phi$. 
Let $T_d' = \, ^{t}T_d$ where $t = \phi(r)$ and $a' = \phi(a)$, $\forall\; b' \in g(T_d')$, it follows that:
$$
\begin{array}{lcr}
b' = \phi(b)  & \Rightarrow & 
\left| \mathrm{lcp}(a,b) \right| = \left| \mathrm{lcp}(a',b') \right|
\end{array}
$$
Furthermore, $\forall\; c \in g(T_q)\; s.t.\; \left| \mathrm{lcp}(a,b) \right| \neq \left| \mathrm{lcp}(a,c) \right| $, we have
$$
\begin{array}{lcr}
\left| \mathrm{lcp}(a,b) \right| = \left| \mathrm{lcp}(a',b') \right|
& \Rightarrow &
b' \neq \phi(c)
\end{array} 
$$
\textit{Justification.} 
Because $a,b \in g(T_q)$, thus $a_0 = b_0 = r$, we make sure $\mathrm{lcp}(a,b) \ge 1$. 
Denote the path of $a = a_0 \ldots a_n a_{n+1} \ldots a_{l-1}$, similarly the path of $b=b_0 \ldots b_n b_{n+1} \ldots b_{m-1}$,
where the length of each $l,m \ge 1$ and $a_i = b_i,\, 0 \le i \le n \le \min(l-1, m-1)$ while $a_{n+1} \neq b_{n+1}$ if $l,m > 1$.
On the other hand $a' = \phi(a)$ and $b' \in g(\,^{t}T_d)$, therefore $a'_0 = \phi(a_0) = \phi(r) = t = b'_0$.
For the first conclusion, if $b' = \phi(b)$, there are two cases. If any of $|a|$ or $|b|$ is equal to one then $\left| \mathrm{lcp}(a,b) \right| = |(r)| = |(t)| = \left| \mathrm{lcp}(a',b') \right| = 1$;
Otherwise if $l,m > 1$, path $a_0 \ldots a_n = b_0 \ldots b_n$ and $a_{n+1} \neq b_{n+1}$ follow that $\phi(a_0 \ldots a_n) = \phi(b_0 \ldots b_n)$ and $\phi(a_{n+1}) \neq \phi(b_{n+1})$ by definition.
Because edge $(\phi(a_n), \phi(a_{n+1}))$ and $(\phi(b_n), \phi(b_{n+1}))$ are also in $E(T'_d)$, 
we see $\left| \mathrm{lcp}(a,b) \right| = \left| \mathrm{lcp}(a',b') \right| = n$.
For the second conclusion, we prove by contradiction. 
Assume $b' = \phi(c)$, by the first conclusion we know $\left| \mathrm{lcp}(a,c) \right| = \left| \mathrm{lcp}(a',b') \right|$.
On the other hand, because $\left| \mathrm{lcp}(a,c) \right| \neq \left| \mathrm{lcp}(a,b) \right| =  \left| \mathrm{lcp}(a',b') \right|$, 
thus $\left| \mathrm{lcp}(a,c) \right| \neq \left| \mathrm{lcp}(a',b') \right|$ which is impossible. 

\subsubsection*{Observation \#4} 
Given an index $\Pi$ and a formula tree $T_q$, $\forall\; T_d \in \Pi$:
If $T_q \preceq_l T_d$ on $\Phi$, then $\exists\; \hat{a} \in \mathbf{L},\; s.t.$
$$
T_d \in \bigcap_{a \in L} \mathcal{I}_{\Pi}(a)
$$
where $L = \ell(g(T_q)) \cdot \hat{a}$.

\noindent \textit{Justification.} 
Denote the root of $T_q$ and $T_d$ as $r$ and $s$ respectively. 
Let $\hat{p}$ be the path determined by vertices from $t=\phi(r)$ to $s$ in $T_d$,
and $\,^1p, \,^2p \ldots \,^np,\; n \ge 1$ be all the leaf-node paths in $T_q$.
Then $\hat{a} = \ell(\hat{p})$, this is because:
$L = \ell(\{ \,^1p, \,^2p \ldots \,^np \}) \cdot \hat{a} = 
\ell(\{ \phi(\,^1p), \phi(\,^2p) \ldots \phi(\,^np) \}) \cdot \ell(\hat{p}) =
\{ \ell(\phi(\,^1p) \cdot \hat{p}), \ell(\phi(\,^2p) \cdot \hat{p}) \ldots \ell(\phi(\,^np) \cdot \hat{p}) \}
$. 
According to definition~\ref{frmlsubtreeDef} and $t=\phi(r)$, we have $\phi(\,^ip) \cdot \hat{p} \in g(T_d),\; 1 \le i \le n$.
Since $ T_d \in \Pi$, $T_d$ is indexed in $\Pi$ with respect to each of the elements in $L$, that is to say $\forall\; a \in L, \; T_d \in \mathcal{I}_{\Pi}(a)$.

\subsection{Interpretation}
\label{labelinterp}
The observations above offer some insights on how to test a substructure of a mathematical expression and how to search for an indexed mathematical expression. 

First we give some explanations on the definition.
A formula subtree relation defined in \ref{frmlsubtreeDef} describes not only a sub-structure relation between two math expressions, it also requires a label similarity and leaf inclusion.
Because structure shape (subtree isomorphic) is not only one factor to determine whether a math formula is a subexpression of another. 
Given expression in figure~\ref{oprtreeExample} as an example, where $b+c$ is an subexpression of $a \times (b+c)$, and we consider ``similar" between the two.
However, if expressions with different symbols but in similar semantics are given, e.g. $b \oplus c$ or $b \pm c$, 
they should also be considered as similar to $a \times (b+c)$ because both the operations has the similar semantical meaning as ``add". 
These operations should be labeled the value of which all the similar operation tokens are the same. 
Also, operation tree representation generally puts operator in the intermediate nodes and operands in the leaves, so it is not common to address a sub-structure without leaves, like ``$a \times + $". So a structure-similarity relation of two should also contain their leaves.

Now that we have defined our structure similarity rule as whether two trees $T_q$ and $T_d$ can satisfy: $T_q \preceq_l T_d$. We break down a formula tree into leaf-root paths $p$ and index the label of each path $\ell(p)$. So if given a ``similar" path $q$, we can further find the previous trees that also have $\ell(q)$ as its labeled path.

In section~\ref{observationlabel}, the first observation gives some constrains to test if two leaf-node paths are similar without knowing the complete tree from which they are generated.
However, comparing all the paths from the index one by one would be very inefficient. Observation \#4 suggests if we search the index by all the generated leaf-node paths from a tree at the same time, then we may just need to look into an intersected region instead of the whole collection.
Because every tree indexed ($T_d \in \Pi$) and matched by the query will be found at the intersection of index with respect to paths starting from each query leaf-root, 
furthermore, the search paths from these start points (indicated by $\ell(g(T_q))$ set), is the same (indicated by $\hat{a}$). Therefore we can ``merge" the paths ahead and prune those paths not in common. Level by level, we will finally find the matched tree.

\begin{figure}
\begin{minipage}[b]{2.65in}
\begin{center}
\includegraphics[height=1.8in]{not-necessary}
\\ $(a+b) \times (c+d) \times e$
\end{center}
\end{minipage}
\hspace*{.38in}
\begin{minipage}[b]{2.65in}
\begin{center}
{\includegraphics[height=1.8in]{not-necessary2}}
\\ $(a+b+c+d) \times e$
\end{center}
\end{minipage}
\caption{Leaf-root paths with different structure}\label{notnecessary}
\end{figure}

However, knowing the matched tree in in a set does not necessarily mean all the tree in the set match with query. 
Figure~\ref{notnecessary} gives one cases where two set of leaf-root paths are identical while the structures from which they are generated are different, and not in any sub-tree relation. If left figure is the query, then we can certainly find the tree in right figure as long as it is indexed, indicated by observation \#4 in section~\ref{observationlabel}.
Although leaf-root paths offer some desired properties, whether the trees found through searching sub-paths of a query are also structure isomorphic with the query tree is still unknown. 

Observations \#2 and \#3 in section~\ref{observationlabel} offer the way to test structure isomorphic.
The former is a sufficient condition to test structure isomorphic, but the tree must first have only one leaf-root path. The latter states two necessary conditions to be a formula subtree of another.
This leads to an idea to decompose the tree and divide the problem into subtree matching problems by ruling out impossible matches between leaf-root paths using observation \#3, until it is obvious to conclude the structure isomorphic in a sub-problem by using observation \#2.

\begin{figure}
\begin{minipage}[b]{2.65in}
\begin{center}
\includegraphics[height=2.8in,width=2.7in]{lpd}
\\ (a)
\end{center}
\end{minipage}
\hspace*{.38in}
\begin{minipage}[b]{2.65in}
\begin{center}
{\includegraphics[height=2.8in,width=2.5in]{lpd2}}
\\ (b) 
\end{center}
\end{minipage}
\caption{Formula subtree matching}\label{submatch}
\end{figure}

\subsection{Structure matching}
Here we propose and describe an algorithm for formula subtree matching based on the interpretation in section~\ref{labelinterp}.
Figure~\ref{submatch} illustrates a general case in which query tree (a) is trying to match a document tree (b).

Initially every leaf-root path in (a) should be associated with a set of leaf-root paths in (b) that are possible (by the constrains of observation~\#1 in \ref{observationlabel}) to be isomorphic, we call this set candidate set. For example the candidate set of path $a$ in (a) probably is $\{a',\ b'\}$ in (b) if the nodes are assigned universally the same label. 
Then we arbitrarily choose a path in (a) as a reference path (heuristically a \textit{heavy path}~\cite{heavypathde}), for each of the paths in its candidate set, we choose it as reference path in (b), and suppose we choose $a'$ here. At this time we can apply the two constrains from observation~\#3 and ruling out some impossible isomorphic paths in candidate set of each path in (a) and divide the problems further. 
For example, because $\left| \mathrm{lcp}(a,b) \right| = \left| \mathrm{lcp}(a',b') \right|$, we know $b'$ is still in candidate set of $b\,$; while $b'$ is not in candidate of $c$ anymore because $\left| \mathrm{lcp}(a,b) \right| \neq \left| \mathrm{lcp}(a,c) \right|$. 
After going through these eliminations for each leaf-node path (except the reference path $a$) in (a), we now have two similar subproblems: $c$ as a subtree along with its candidate set, and $b$ as a subtree along with its candidate set. 
We can apply this algorithm recursively until a very simple subproblem is encountered, that can be solved by observation~\#2. During this process, if we find any candidate set to be empty, we stop the subproblem process and change to another reference path or stop the algorithm completely if every possible reference path is evaluated.

The detailed algorithm is described in figure~\ref{submatchalgo}. 
The main procedure is \textit{decomposeAndMatch} where the argument $Q$ and $C$ is the set of leaf-root paths in query tree and the candidate sets associated with all leaf-root paths respectively.
The procedure returns SUCC if a match is found, otherwise FAIL is returned indicating no possible match.

\begin{figure}
\begin{algorithmic}[1]

\Procedure{removeCandidate}{$d,Q,C$} 
\For {$a \in Q$}
\If{$C_a = \emptyset$}
\State \textbf{return} $\emptyset$ 
\Else
\State {$C_a := C_a - \{d\}$} 
\EndIf
\EndFor
\State \textbf{return} $C$
\EndProcedure

\State {}

\Procedure{match}{$a, a', Q, C$}
\For {$b \in Q$}
\State $t := \mathrm{lcp}(a,b)$
\State $Q_t := Q_t \cup \{b\}$
\State $P := P \cup \{t\}$
\EndFor
\For {$t \in P$}
\For {$b \in Q_t$}
\For {$b' \in C_b$}
\If {$t \not= \mathrm{lcp}(a',b')$} 
\State $C := $ \Call{removeCandidate}{$b', Q_t, C$}
\If {$|C| = 0$} 
\State \textbf{return} FAIL
\EndIf
\EndIf
\EndFor
\EndFor
\If {\Call{decomposeAndMatch}{$Q_t, C$} = FAIL} 
\State \textbf{return} FAIL
\EndIf
\EndFor
\State \textbf{return} SUCC 
\EndProcedure

\State {}

\Procedure{decomposeAndMatch}{$Q, C$}
\If {$Q = \emptyset$} \textbf{return} SUCC 
\EndIf
\State $a$ := OnePathIn(Q)
\Comment{Choose a reference path in Q}
\State $Q_{\mathrm{new}} := Q - \{a\}$
\For {$a' \in C_a$}
\State $C_{\mathrm{new}} := $ \Call{removeCandidate}{$a', Q_{\mathrm{new}}, C$}
\If {$C_{\mathrm{new}} = \emptyset$} \textbf{return} FAIL 
\EndIf
\If {\Call{match}{$a, a', Q_{\mathrm{new}}, C_{\mathrm{new}}$}}
\textbf{return} SUCC 
\EndIf
\EndFor
\State \textbf{return} FAIL
\EndProcedure

\end{algorithmic}
\caption{The decompose-and-match algorithm}\label{submatchalgo}
\end{figure}

\section{Symbolic Similarity}
Until now, we have not addressed symbolic similarity yet. 
Although mathematical expression often use symbols interchangeably, symbolic matches is a good way to differentiate similarity, and most importantly, measure some semantic similarity in mathematical language.

Firstly, structure similarity of math expression is either boolean match (subtree or not) or measured with the similarity degree only depend on the subtree depth where expressions are matched. Symbolic similarity will introduce more factors to further distinguish similarity among structural identical math expressions.
Also it is essential to give those with symbolic matches a higher rank because they may imply more semantic similarity. 
For example $E=mc^2$ is considered more meaningful when exact symbols are used rather than just being structure identical with $y=ax^2$.

Secondly, as illustrated in section~\ref{measure_sim}, same mathematical symbols in an expression (or bind variables) usually can only maintain semantical equality if the changes are made by substitutions. (similar to the notion of $\alpha$-equality~\cite{Hindley1986}). This is an important semantic information that we need to capture and certainly it involves comparison of symbols. 

Yet there is one thing to notice here, in many mathematical search systems, a query may be specified with wildcards and thus will match any document with an expression substitution to that wildcard. 
And a query symbol not specified by wildcard is expecting an exact symbolic occurrence in document.
We are not considering wildcards here with the limitation of our substructure matching method. 
And in terms of symbolic wildcard, we also doubt the its demand in mathematical search as it is not common to expect an exact symbol occurrence when we query in mathematical language (also addressed in \cite{mias11a}).

\subsection{Constrains and strategy}
As we have discussed, symbolic similarity is essential to be captured and the considerations addressed above can be summarized by the following two constrains:

\begin{itemize}

\item A document expression with both structure and symbol matches (not necessarily all the symbols) is considered more relevant than that with only structure matches. And the more symbol matches, the more relevant it is.
\item Same symbols in one equation (i.e. bind variables) should be considered more relevant than those with different symbols at the same position.
\end{itemize}

Instead of giving a score function to measure symbolic similarity, we only aim our search method to meet the two constrains above. 

\subsection{Mark-and-cross algorithm}
To achieve this goal, we intuitively take the bind variable with greatest number of occurrence, e.g. $a$ in $a+a+a+b+b+c$, to match as many as symbols of each bind variable in a document expression. 
Whenever a symbol in document expression is matched, we exclude it from matching candidates of the next iteration.
Then choose the bind variable in query with the second number of occurrence to match the candidates of document in the next iteration.

\section{Review on the Method}
\subsection{One step back}
\subsection{Complexity (with state-of-art)}
\subsection{An example}
\label{secIllu}

Analogously,

Our system Cowpie \footnote{demo page: \url{infolab.ece.udel.edu:8912/cowpie/}}

\let\thefootnote\relax\footnote{Contact author: clock126@126.com or
\url{http://www.eecis.udel.edu/~zhongwei}}

MathML vs LaTeX
